<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Doom-Klon Framework</title>
  <style>
    /* Basis-Styles */
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      overflow: hidden;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      image-rendering: pixelated;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    // Setup Canvas
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Spieler-Daten (als Beispiel)
    const player = {
      x: 3.5,
      y: 3.5,
      angle: 0,         // Blickrichtung in Radiant
      health: 100,
      speed: 0.05
    };

    // Beispielhafte Level-Daten (sehr einfach gehalten)
    // 0 = leerer Raum, 1 = Wand
    const level = {
      map: [
        [1,1,1,1,1,1,1,1,1,1],
        [1,0,0,0,0,0,0,0,0,1],
        [1,0,1,0,1,0,1,0,0,1],
        [1,0,1,0,0,0,1,0,0,1],
        [1,0,1,1,1,0,1,0,0,1],
        [1,0,0,0,0,0,1,0,0,1],
        [1,1,1,1,1,1,1,1,1,1]
      ],
      tileSize: 64
    };

    // Tastatureingaben verwalten
    const keys = {};
    window.addEventListener("keydown", e => keys[e.code] = true);
    window.addEventListener("keyup", e => keys[e.code] = false);

    // Haupt-Spielschleife
    function gameLoop() {
      update();
      render();
      requestAnimationFrame(gameLoop);
    }

    // Update-Funktion: Steuereingaben, Spielphysik, Gegner‑KI etc.
    function update() {
      // Beispiel: Vorwärtsbewegung
      if (keys["ArrowUp"]) {
        const nextX = player.x + Math.cos(player.angle) * player.speed;
        const nextY = player.y + Math.sin(player.angle) * player.speed;
        if (level.map[Math.floor(nextY)][Math.floor(nextX)] === 0) {
          player.x = nextX;
          player.y = nextY;
        }
      }
      // Beispiel: Rückwärtsbewegung
      if (keys["ArrowDown"]) {
        const nextX = player.x - Math.cos(player.angle) * player.speed;
        const nextY = player.y - Math.sin(player.angle) * player.speed;
        if (level.map[Math.floor(nextY)][Math.floor(nextX)] === 0) {
          player.x = nextX;
          player.y = nextY;
        }
      }
      // Beispiel: Rotation
      if (keys["ArrowLeft"]) {
        player.angle -= 0.03;
      }
      if (keys["ArrowRight"]) {
        player.angle += 0.03;
      }

      // Hier würden auch Gegner‑Logik, Kollisionen, Waffensysteme etc. aktualisiert
    }

    // Render-Funktion: Zeichnet die Szene (Raycasting‑Engine)
    function render() {
      // Bildschirm löschen
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Beispiel: Minimaler Raycasting-Ansatz für Wand-Rendering
      const fov = Math.PI / 3; // 60° Sichtfeld
      for (let x = 0; x < canvas.width; x++) {
        const cameraX = 2 * x / canvas.width - 1;
        const rayAngle = player.angle + cameraX * (fov / 2);

        // Startposition des Strahls
        let mapX = Math.floor(player.x);
        let mapY = Math.floor(player.y);

        // Berechnung der Distanz-Schritte
        const deltaDistX = Math.abs(1 / Math.cos(rayAngle));
        const deltaDistY = Math.abs(1 / Math.sin(rayAngle));

        let stepX, stepY;
        let sideDistX, sideDistY;

        if (Math.cos(rayAngle) < 0) {
          stepX = -1;
          sideDistX = (player.x - mapX) * deltaDistX;
        } else {
          stepX = 1;
          sideDistX = (mapX + 1.0 - player.x) * deltaDistX;
        }
        if (Math.sin(rayAngle) < 0) {
          stepY = -1;
          sideDistY = (player.y - mapY) * deltaDistY;
        } else {
          stepY = 1;
          sideDistY = (mapY + 1.0 - player.y) * deltaDistY;
        }

        // DDA-Schleife zur Wandfindung
        let hit = false;
        let side;
        while (!hit) {
          if (sideDistX < sideDistY) {
            sideDistX += deltaDistX;
            mapX += stepX;
            side = 0;
          } else {
            sideDistY += deltaDistY;
            mapY += stepY;
            side = 1;
          }
          if (level.map[mapY] && level.map[mapY][mapX] > 0) hit = true;
        }

        // Berechne die Entfernung zur Wand
        let perpWallDist;
        if (side === 0)
          perpWallDist = (mapX - player.x + (1 - stepX) / 2) / Math.cos(rayAngle);
        else
          perpWallDist = (mapY - player.y + (1 - stepY) / 2) / Math.sin(rayAngle);

        // Wandhöhe basierend auf Distanz
        const lineHeight = Math.floor(canvas.height / perpWallDist);
        const drawStart = -lineHeight / 2 + canvas.height / 2;
        ctx.fillStyle = side === 0 ? "#FF5555" : "#AA0000";
        ctx.fillRect(x, drawStart, 1, lineHeight);
      }

      // Hier würden auch Sprites, Gegner, HUD (z.B. Leben, Waffen) etc. gerendert
    }

    // Starte die Spielschleife
    gameLoop();

    // Zusätzliche Module (z.B. Sound-Management, Level-Parser, Gegner‑Klassen) müssten hier hinzugefügt werden.
  </script>
</body>
</html>
