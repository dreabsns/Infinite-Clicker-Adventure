<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Minimaler Doom‑ähnlicher Raycaster</title>
  <style>
    /* Grundlegendes Styling */
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      image-rendering: pixelated;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Ein einfacher 2D-Map (0 = leerer Raum, 1 = Wand)
    const map = [
      [1,1,1,1,1,1,1,1,1,1],
      [1,0,0,0,0,0,0,0,0,1],
      [1,0,1,0,1,0,1,0,0,1],
      [1,0,1,0,0,0,1,0,0,1],
      [1,0,1,1,1,0,1,0,0,1],
      [1,0,0,0,0,0,1,0,0,1],
      [1,1,1,1,1,1,1,1,1,1]
    ];
    const mapWidth = map[0].length;
    const mapHeight = map.length;
    const tileSize = 64; // fiktive Größe – dient nur zur Berechnung

    // Spielerposition und Blickrichtung (in Map‑Einheiten)
    let posX = 3.5, posY = 3.5;  // Startposition
    let dir = 0;               // Blickrichtung in Radiant (0 = nach rechts)
    const fov = Math.PI / 3;   // Sichtfeld (60°)

    // Tastaturzustand
    const keys = {};
    window.addEventListener("keydown", e => keys[e.code] = true);
    window.addEventListener("keyup", e => keys[e.code] = false);

    function update() {
      const moveSpeed = 0.05;
      const rotSpeed = 0.03;
      // Vorwärts bewegen
      if (keys["ArrowUp"]) {
        posX += Math.cos(dir) * moveSpeed;
        posY += Math.sin(dir) * moveSpeed;
        if (map[Math.floor(posY)][Math.floor(posX)] !== 0) {
          posX -= Math.cos(dir) * moveSpeed;
          posY -= Math.sin(dir) * moveSpeed;
        }
      }
      // Rückwärts bewegen
      if (keys["ArrowDown"]) {
        posX -= Math.cos(dir) * moveSpeed;
        posY -= Math.sin(dir) * moveSpeed;
        if (map[Math.floor(posY)][Math.floor(posX)] !== 0) {
          posX += Math.cos(dir) * moveSpeed;
          posY += Math.sin(dir) * moveSpeed;
        }
      }
      // Rotieren
      if (keys["ArrowLeft"]) {
        dir -= rotSpeed;
      }
      if (keys["ArrowRight"]) {
        dir += rotSpeed;
      }
    }

    function render() {
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Für jeden vertikalen Streifen (Pixel-Spalte) am Bildschirm:
      for (let x = 0; x < canvas.width; x++) {
        // Berechne den Kamerakoeffizienten von -1 bis 1
        const cameraX = 2 * x / canvas.width - 1;
        // Berechne die Richtung des Strahls
        const rayDir = dir + cameraX * (fov / 2);

        // Startposition in der Map (Integer-Koordinaten)
        let mapX = Math.floor(posX);
        let mapY = Math.floor(posY);

        // Länge des Strahls bis zur nächsten x‑ oder y‑Seiten
        const deltaDistX = Math.abs(1 / Math.cos(rayDir));
        const deltaDistY = Math.abs(1 / Math.sin(rayDir));

        let stepX, stepY;
        let sideDistX, sideDistY;

        if (Math.cos(rayDir) < 0) {
          stepX = -1;
          sideDistX = (posX - mapX) * deltaDistX;
        } else {
          stepX = 1;
          sideDistX = (mapX + 1.0 - posX) * deltaDistX;
        }
        if (Math.sin(rayDir) < 0) {
          stepY = -1;
          sideDistY = (posY - mapY) * deltaDistY;
        } else {
          stepY = 1;
          sideDistY = (mapY + 1.0 - posY) * deltaDistY;
        }

        // DDA-Schleife (Digital Differential Analyzer) zur Wandkollision
        let hit = 0;
        let side;
        while (hit === 0) {
          if (sideDistX < sideDistY) {
            sideDistX += deltaDistX;
            mapX += stepX;
            side = 0;
          } else {
            sideDistY += deltaDistY;
            mapY += stepY;
            side = 1;
          }
          if (map[mapY] && map[mapY][mapX] > 0) hit = 1;
        }

        // Berechne die Entfernung zur Wand
        let perpWallDist;
        if (side === 0)
          perpWallDist = (mapX - posX + (1 - stepX) / 2) / Math.cos(rayDir);
        else
          perpWallDist = (mapY - posY + (1 - stepY) / 2) / Math.sin(rayDir);

        // Höhe der Wand-Säule
        const lineHeight = Math.floor(canvas.height / perpWallDist);
        const drawStart = -lineHeight / 2 + canvas.height / 2;
        // Einfache Farbauswahl: unterschiedliche Farbtöne je nach Seitenlage
        ctx.fillStyle = side === 0 ? "#FF5555" : "#AA0000";
        ctx.fillRect(x, drawStart, 1, lineHeight);
      }
    }

    function gameLoop() {
      update();
      render();
      requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
</body>
</html>
